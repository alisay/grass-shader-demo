{"version":3,"sources":["resources/blade_diffuse.png","resources/blade_alpha.jpg","GrassMaterial.js","Grass.js","App.js","index.js"],"names":["GrassMaterial","shaderMaterial","bladeHeight","map","alphaMap","time","self","side","THREE","extend","simplex","SimplexNoise","Math","random","Grass","options","bW","bH","joints","width","instances","materialRef","useRef","useLoader","bladeDiffuse","bladeAlpha","texture","attributeData","useMemo","offsets","orientations","stretches","halfRootAngleSin","halfRootAngleCos","quaternion_0","quaternion_1","min","max","i","offsetX","offsetZ","offsetY","getYPosition","push","angle","PI","sin","cos","RotationAxis","x","y","z","w","set","normalize","multiplyQuaternions","getAttributeData","baseGeom","translate","groundGeo","geo","Geometry","fromBufferGeometry","verticesNeedUpdate","lookAt","vertices","length","v","computeVertexNormals","toBufferGeometry","useFrame","state","current","uniforms","value","clock","elapsedTime","index","attributes","position","uv","attachObject","args","Float32Array","ref","geometry","color","q1","q2","noise2D","App","camera","Sky","azimuth","inclination","distance","fallback","OrbitControls","minPolarAngle","maxPolarAngle","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"oPAAe,MAA0B,0CCA1B,MAA0B,wC,QCInCA,EAAgBC,YACpB,CAAEC,YAAa,EAAGC,IAAK,KAAMC,SAAU,KAAMC,KAAM,GADjB,i7KAsGlC,SAACC,GACCA,EAAKC,KAAOC,gBAIhBC,YAAO,CAAET,kB,YCpGHU,EAAU,IAAIC,IAAaC,KAAKC,QAEvB,SAASC,EAAT,GAA8F,IAAD,IAA5EC,eAA4E,MAAlE,CAAEC,GAAI,IAAMC,GAAI,EAAGC,OAAQ,GAAuC,MAAlCC,aAAkC,MAA1B,IAA0B,MAArBC,iBAAqB,MAAT,IAAS,EAClGJ,EAAmBD,EAAnBC,GAAIC,EAAeF,EAAfE,GAAIC,EAAWH,EAAXG,OACVG,EAAcC,mBACpB,EAA4BC,YAAUf,gBAAqB,CAACgB,EAAcC,IAA1E,mBAAOC,EAAP,KAAgBtB,EAAhB,KACMuB,EAAgBC,mBAAQ,kBAiChC,SAA0BR,EAAWD,GAenC,IAdA,IAAMU,EAAU,GACVC,EAAe,GACfC,EAAY,GACZC,EAAmB,GACnBC,EAAmB,GAErBC,EAAe,IAAI1B,UACnB2B,EAAe,IAAI3B,UAGjB4B,GAAO,IACPC,EAAM,IAGHC,EAAI,EAAGA,EAAIlB,EAAWkB,IAAK,CAElC,IAAMC,EAAU3B,KAAKC,SAAWM,EAAQA,EAAQ,EAC1CqB,EAAU5B,KAAKC,SAAWM,EAAQA,EAAQ,EAC1CsB,EAAUC,EAAaH,EAASC,GACtCX,EAAQc,KAAKJ,EAASE,EAASD,GAI/B,IAAII,EAAQhC,KAAKiC,GAAKjC,KAAKC,UAAY,EAAID,KAAKiC,IAChDb,EAAiBW,KAAK/B,KAAKkC,IAAI,GAAMF,IACrCX,EAAiBU,KAAK/B,KAAKmC,IAAI,GAAMH,IAErC,IAAII,EAAe,IAAIxC,UAAc,EAAG,EAAG,GACvCyC,EAAID,EAAaC,EAAIrC,KAAKkC,IAAIF,EAAQ,GACtCM,EAAIF,EAAaE,EAAItC,KAAKkC,IAAIF,EAAQ,GACtCO,EAAIH,EAAaG,EAAIvC,KAAKkC,IAAIF,EAAQ,GACtCQ,EAAIxC,KAAKmC,IAAIH,EAAQ,GACzBV,EAAamB,IAAIJ,EAAGC,EAAGC,EAAGC,GAAGE,YAG7BV,EAAQhC,KAAKC,UAAYwB,EAAMD,GAAOA,EAEtCa,GADAD,EAAe,IAAIxC,UAAc,EAAG,EAAG,IACtByC,EAAIrC,KAAKkC,IAAIF,EAAQ,GACtCM,EAAIF,EAAaE,EAAItC,KAAKkC,IAAIF,EAAQ,GACtCO,EAAIH,EAAaG,EAAIvC,KAAKkC,IAAIF,EAAQ,GACtCQ,EAAIxC,KAAKmC,IAAIH,EAAQ,GACrBT,EAAakB,IAAIJ,EAAGC,EAAGC,EAAGC,GAAGE,YAG7BpB,EAAeqB,EAAoBrB,EAAcC,GAGjDS,EAAQhC,KAAKC,UAAYwB,EAAMD,GAAOA,EAEtCa,GADAD,EAAe,IAAIxC,UAAc,EAAG,EAAG,IACtByC,EAAIrC,KAAKkC,IAAIF,EAAQ,GACtCM,EAAIF,EAAaE,EAAItC,KAAKkC,IAAIF,EAAQ,GACtCO,EAAIH,EAAaG,EAAIvC,KAAKkC,IAAIF,EAAQ,GACtCQ,EAAIxC,KAAKmC,IAAIH,EAAQ,GACrBT,EAAakB,IAAIJ,EAAGC,EAAGC,EAAGC,GAAGE,YAG7BpB,EAAeqB,EAAoBrB,EAAcC,GAEjDL,EAAaa,KAAKT,EAAae,EAAGf,EAAagB,EAAGhB,EAAaiB,EAAGjB,EAAakB,GAG3Ed,EAAIlB,EAAY,EAClBW,EAAUY,KAAqB,IAAhB/B,KAAKC,UAEpBkB,EAAUY,KAAK/B,KAAKC,UAIxB,MAAO,CACLgB,UACAC,eACAC,YACAE,mBACAD,oBA3GkCwB,CAAiBpC,EAAWD,KAAQ,CAACC,EAAWD,IAC9EsC,EAAW7B,mBAAQ,kBAAM,IAAIpB,sBAA0BQ,EAAIC,EAAI,EAAGC,GAAQwC,UAAU,EAAGzC,EAAK,EAAG,KAAI,CAACF,IACpG4C,EAAY/B,mBAAQ,WACxB,IAAMgC,GAAM,IAAIC,KAAWC,mBAAmB,IAAItD,gBAAoBW,EAAOA,EAAO,GAAI,KACxFyC,EAAIG,oBAAqB,EACzBH,EAAII,OAAO,IAAIxD,UAAc,EAAG,EAAG,IACnC,IAAK,IAAI8B,EAAI,EAAGA,EAAIsB,EAAIK,SAASC,OAAQ5B,IAAK,CAC5C,IAAM6B,EAAIP,EAAIK,SAAS3B,GACvB6B,EAAEjB,EAAIR,EAAayB,EAAElB,EAAGkB,EAAEhB,GAG5B,OADAS,EAAIQ,uBACGR,EAAIS,qBACV,CAAClD,IAEJ,OADAmD,aAAS,SAACC,GAAD,OAAYlD,EAAYmD,QAAQC,SAASpE,KAAKqE,MAAQH,EAAMI,MAAMC,YAAc,KAEvF,qCACE,iCACE,0CAAyBC,MAAOpB,EAASoB,MAAO,sBAAqBpB,EAASqB,WAAWC,SAAU,gBAAetB,EAASqB,WAAWE,GAAtI,UACE,0CAA0BC,aAAc,CAAC,aAAc,UAAWC,KAAM,CAAC,IAAIC,aAAaxD,EAAcE,SAAU,KAClH,0CAA0BoD,aAAc,CAAC,aAAc,eAAgBC,KAAM,CAAC,IAAIC,aAAaxD,EAAcG,cAAe,KAC5H,0CAA0BmD,aAAc,CAAC,aAAc,WAAYC,KAAM,CAAC,IAAIC,aAAaxD,EAAcI,WAAY,KACrH,0CAA0BkD,aAAc,CAAC,aAAc,oBAAqBC,KAAM,CAAC,IAAIC,aAAaxD,EAAcK,kBAAmB,KACrI,0CAA0BiD,aAAc,CAAC,aAAc,oBAAqBC,KAAM,CAAC,IAAIC,aAAaxD,EAAcM,kBAAmB,QAEvI,+BAAemD,IAAK/D,EAAalB,IAAKuB,EAAStB,SAAUA,OAE3D,sBAAM2E,SAAU,CAAC,EAAG,EAAG,GAAIM,SAAU1B,EAArC,SACE,sCAAsB2B,MAAM,iBAoFpC,SAAS/B,EAAoBgC,EAAIC,GAC/B,IAAMvC,EAAIsC,EAAGtC,EAAIuC,EAAGpC,EAAImC,EAAGrC,EAAIsC,EAAGrC,EAAIoC,EAAGpC,EAAIqC,EAAGtC,EAAIqC,EAAGnC,EAAIoC,EAAGvC,EACxDC,GAAKqC,EAAGtC,EAAIuC,EAAGrC,EAAIoC,EAAGrC,EAAIsC,EAAGpC,EAAImC,EAAGpC,EAAIqC,EAAGvC,EAAIsC,EAAGnC,EAAIoC,EAAGtC,EACzDC,EAAIoC,EAAGtC,EAAIuC,EAAGtC,EAAIqC,EAAGrC,EAAIsC,EAAGvC,EAAIsC,EAAGpC,EAAIqC,EAAGpC,EAAImC,EAAGnC,EAAIoC,EAAGrC,EACxDC,GAAKmC,EAAGtC,EAAIuC,EAAGvC,EAAIsC,EAAGrC,EAAIsC,EAAGtC,EAAIqC,EAAGpC,EAAIqC,EAAGrC,EAAIoC,EAAGnC,EAAIoC,EAAGpC,EAC/D,OAAO,IAAI5C,UAAcyC,EAAGC,EAAGC,EAAGC,GAGpC,SAASV,EAAaO,EAAGE,GACvB,IAAID,EAAI,EAAIxC,EAAQ+E,QAAQxC,EAAI,GAAIE,EAAI,IAGxC,OAFAD,GAAK,EAAIxC,EAAQ+E,QAAQxC,EAAI,IAAKE,EAAI,KACtCD,GAAK,GAAMxC,EAAQ+E,QAAQxC,EAAI,GAAIE,EAAI,ICtI1B,SAASuC,IACtB,OACE,eAAC,IAAD,CAAQC,OAAQ,CAAEZ,SAAU,CAAC,GAAI,GAAI,KAArC,UACE,cAACa,EAAA,EAAD,CAAKC,QAAS,EAAGC,YAAa,GAAKC,SAAU,MAC7C,iCACA,4BAAYhB,SAAU,CAAC,GAAI,GAAI,MAC/B,cAAC,WAAD,CAAUiB,SAAU,KAApB,SACE,cAAClF,EAAD,MAEF,cAACmF,EAAA,EAAD,CAAeC,cAAetF,KAAKiC,GAAK,EAAGsD,cAAevF,KAAKiC,GAAK,S,MCT1EuD,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAACZ,EAAD,MAEFa,SAASC,eAAe,W","file":"static/js/main.8da6522b.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/blade_diffuse.7a91419c.png\";","export default __webpack_public_path__ + \"static/media/blade_alpha.fd72bbc9.jpg\";","import * as THREE from \"three\"\nimport { shaderMaterial } from \"@react-three/drei\"\nimport { extend } from \"@react-three/fiber\"\n\nconst GrassMaterial = shaderMaterial(\n  { bladeHeight: 1, map: null, alphaMap: null, time: 0 },\n  `   precision mediump float;\n      attribute vec3 offset;\n      attribute vec4 orientation;\n      attribute float halfRootAngleSin;\n      attribute float halfRootAngleCos;\n      attribute float stretch;\n      uniform float time;\n      uniform float bladeHeight;\n      varying vec2 vUv;\n      varying float frc;\n      \n      //WEBGL-NOISE FROM https://github.com/stegu/webgl-noise\n      //Description : Array and textureless GLSL 2D simplex noise function. Author : Ian McEwan, Ashima Arts. Maintainer : stegu Lastmod : 20110822 (ijm) License : Copyright (C) 2011 Ashima Arts. All rights reserved. Distributed under the MIT License. See LICENSE file. https://github.com/ashima/webgl-noise https://github.com/stegu/webgl-noise      \n      vec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;} vec2 mod289(vec2 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;} vec3 permute(vec3 x) {return mod289(((x*34.0)+1.0)*x);} float snoise(vec2 v){const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439); vec2 i  = floor(v + dot(v, C.yy) ); vec2 x0 = v -   i + dot(i, C.xx); vec2 i1; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod289(i); vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 )); vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0); m = m*m ; m = m*m ; vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ); vec3 g; g.x  = a0.x  * x0.x  + h.x  * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g);}\n      //END NOISE\n      \n      //https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\n      vec3 rotateVectorByQuaternion( vec3 v, vec4 q){\n        return 2.0 * cross(q.xyz, v * q.w + cross(q.xyz, v)) + v;\n      }\n      \n      //https://en.wikipedia.org/wiki/Slerp\n      vec4 slerp(vec4 v0, vec4 v1, float t) {\n        // Only unit quaternions are valid rotations.\n        // Normalize to avoid undefined behavior.\n        normalize(v0);\n        normalize(v1);\n      \n        // Compute the cosine of the angle between the two vectors.\n        float dot_ = dot(v0, v1);\n      \n        // If the dot product is negative, slerp won't take\n        // the shorter path. Note that v1 and -v1 are equivalent when\n        // the negation is applied to all four components. Fix by \n        // reversing one quaternion.\n        if (dot_ < 0.0) {\n          v1 = -v1;\n          dot_ = -dot_;\n        }  \n      \n        const float DOT_THRESHOLD = 0.9995;\n        if (dot_ > DOT_THRESHOLD) {\n          // If the inputs are too close for comfort, linearly interpolate\n          // and normalize the result.\n          vec4 result = t*(v1 - v0) + v0;\n          normalize(result);\n          return result;\n        }\n      \n        // Since dot is in range [0, DOT_THRESHOLD], acos is safe\n        float theta_0 = acos(dot_);       // theta_0 = angle between input vectors\n        float theta = theta_0*t;          // theta = angle between v0 and result\n        float sin_theta = sin(theta);     // compute this value only once\n        float sin_theta_0 = sin(theta_0); // compute this value only once\n        float s0 = cos(theta) - dot_ * sin_theta / sin_theta_0;  // == sin(theta_0 - theta) / sin(theta_0)\n        float s1 = sin_theta / sin_theta_0;\n        return (s0 * v0) + (s1 * v1);\n      }\n      \n      void main() {\n        //Relative position of vertex along the mesh Y direction\n        frc = position.y/float(bladeHeight);\n        //Get wind data from simplex noise \n        float noise = 1.0-(snoise(vec2((time-offset.x/50.0), (time-offset.z/50.0)))); \n        //Define the direction of an unbent blade of grass rotated around the Y axis\n        vec4 direction = vec4(0.0, halfRootAngleSin, 0.0, halfRootAngleCos);\n        //Interpolate between the unbent direction and the direction of growth calculated on the CPU. \n        //Using the relative location of the vertex along the Y axis as the weight, we get a smooth bend\n        direction = slerp(direction, orientation, frc);\n        vec3 vPosition = vec3(position.x, position.y + position.y * stretch, position.z);\n        vPosition = rotateVectorByQuaternion(vPosition, direction);\n      \n       //Apply wind\n       float halfAngle = noise * 0.15;\n        vPosition = rotateVectorByQuaternion(vPosition, normalize(vec4(sin(halfAngle), 0.0, -sin(halfAngle), cos(halfAngle))));\n        //UV for texture\n        vUv = uv;\n        //Calculate final position of the vertex from the world offset and the above shenanigans \n        gl_Position = projectionMatrix * modelViewMatrix * vec4(offset + vPosition, 1.0 );\n      }`,\n  `\n      precision mediump float;\n      uniform sampler2D map;\n      uniform sampler2D alphaMap;\n      varying vec2 vUv;\n      varying float frc;\n      \n      void main() {\n        //Get transparency information from alpha map\n        float alpha = texture2D(alphaMap, vUv).r;\n        //If transparent, don't draw\n        if(alpha < 0.15) discard;\n        //Get colour data from texture\n        vec4 col = vec4(texture2D(map, vUv));\n        //Add more green towards root\n        col = mix(vec4(0.0, 0.6, 0.0, 1.0), col, frc);\n        //Add a shadow towards root\n        col = mix(vec4(0.0, 0.1, 0.0, 1.0), col, frc);\n        gl_FragColor = col;\n      }`,\n  (self) => {\n    self.side = THREE.DoubleSide\n  },\n)\n\nextend({ GrassMaterial })\n","// Based on https://codepen.io/al-ro/pen/jJJygQ by al-ro, but rewritten in react-three-fiber\nimport * as THREE from \"three\"\nimport React, { useRef, useMemo } from \"react\"\nimport SimplexNoise from \"simplex-noise\"\nimport { useFrame, useLoader } from \"@react-three/fiber\"\nimport { Geometry } from \"three/examples/jsm/deprecated/Geometry\"\n//These have been taken from \"Realistic real-time grass rendering\" by Eddie Lee, 2010\nimport bladeDiffuse from \"./resources/blade_diffuse.png\"\nimport bladeAlpha from \"./resources/blade_alpha.jpg\"\nimport \"./GrassMaterial\"\n\nconst simplex = new SimplexNoise(Math.random)\n\nexport default function Grass({ options = { bW: 0.12, bH: 1, joints: 5 }, width = 100, instances = 50000 }) {\n  const { bW, bH, joints } = options\n  const materialRef = useRef()\n  const [texture, alphaMap] = useLoader(THREE.TextureLoader, [bladeDiffuse, bladeAlpha])\n  const attributeData = useMemo(() => getAttributeData(instances, width), [instances, width])\n  const baseGeom = useMemo(() => new THREE.PlaneBufferGeometry(bW, bH, 1, joints).translate(0, bH / 2, 0), [options])\n  const groundGeo = useMemo(() => {\n    const geo = new Geometry().fromBufferGeometry(new THREE.PlaneGeometry(width, width, 32, 32))\n    geo.verticesNeedUpdate = true\n    geo.lookAt(new THREE.Vector3(0, 1, 0))\n    for (let i = 0; i < geo.vertices.length; i++) {\n      const v = geo.vertices[i]\n      v.y = getYPosition(v.x, v.z)\n    }\n    geo.computeVertexNormals()\n    return geo.toBufferGeometry()\n  }, [width])\n  useFrame((state) => (materialRef.current.uniforms.time.value = state.clock.elapsedTime / 4))\n  return (\n    <>\n      <mesh>\n        <instancedBufferGeometry index={baseGeom.index} attributes-position={baseGeom.attributes.position} attributes-uv={baseGeom.attributes.uv}>\n          <instancedBufferAttribute attachObject={[\"attributes\", \"offset\"]} args={[new Float32Array(attributeData.offsets), 3]} />\n          <instancedBufferAttribute attachObject={[\"attributes\", \"orientation\"]} args={[new Float32Array(attributeData.orientations), 4]} />\n          <instancedBufferAttribute attachObject={[\"attributes\", \"stretch\"]} args={[new Float32Array(attributeData.stretches), 1]} />\n          <instancedBufferAttribute attachObject={[\"attributes\", \"halfRootAngleSin\"]} args={[new Float32Array(attributeData.halfRootAngleSin), 1]} />\n          <instancedBufferAttribute attachObject={[\"attributes\", \"halfRootAngleCos\"]} args={[new Float32Array(attributeData.halfRootAngleCos), 1]} />\n        </instancedBufferGeometry>\n        <grassMaterial ref={materialRef} map={texture} alphaMap={alphaMap} />\n      </mesh>\n      <mesh position={[0, 0, 0]} geometry={groundGeo}>\n        <meshStandardMaterial color=\"#000f00\" />\n      </mesh>\n    </>\n  )\n}\n\nfunction getAttributeData(instances, width) {\n  const offsets = []\n  const orientations = []\n  const stretches = []\n  const halfRootAngleSin = []\n  const halfRootAngleCos = []\n\n  let quaternion_0 = new THREE.Vector4()\n  let quaternion_1 = new THREE.Vector4()\n\n  //The min and max angle for the growth direction (in radians)\n  const min = -0.25\n  const max = 0.25\n\n  //For each instance of the grass blade\n  for (let i = 0; i < instances; i++) {\n    //Offset of the roots\n    const offsetX = Math.random() * width - width / 2\n    const offsetZ = Math.random() * width - width / 2\n    const offsetY = getYPosition(offsetX, offsetZ)\n    offsets.push(offsetX, offsetY, offsetZ)\n\n    //Define random growth directions\n    //Rotate around Y\n    let angle = Math.PI - Math.random() * (2 * Math.PI)\n    halfRootAngleSin.push(Math.sin(0.5 * angle))\n    halfRootAngleCos.push(Math.cos(0.5 * angle))\n\n    let RotationAxis = new THREE.Vector3(0, 1, 0)\n    let x = RotationAxis.x * Math.sin(angle / 2.0)\n    let y = RotationAxis.y * Math.sin(angle / 2.0)\n    let z = RotationAxis.z * Math.sin(angle / 2.0)\n    let w = Math.cos(angle / 2.0)\n    quaternion_0.set(x, y, z, w).normalize()\n\n    //Rotate around X\n    angle = Math.random() * (max - min) + min\n    RotationAxis = new THREE.Vector3(1, 0, 0)\n    x = RotationAxis.x * Math.sin(angle / 2.0)\n    y = RotationAxis.y * Math.sin(angle / 2.0)\n    z = RotationAxis.z * Math.sin(angle / 2.0)\n    w = Math.cos(angle / 2.0)\n    quaternion_1.set(x, y, z, w).normalize()\n\n    //Combine rotations to a single quaternion\n    quaternion_0 = multiplyQuaternions(quaternion_0, quaternion_1)\n\n    //Rotate around Z\n    angle = Math.random() * (max - min) + min\n    RotationAxis = new THREE.Vector3(0, 0, 1)\n    x = RotationAxis.x * Math.sin(angle / 2.0)\n    y = RotationAxis.y * Math.sin(angle / 2.0)\n    z = RotationAxis.z * Math.sin(angle / 2.0)\n    w = Math.cos(angle / 2.0)\n    quaternion_1.set(x, y, z, w).normalize()\n\n    //Combine rotations to a single quaternion\n    quaternion_0 = multiplyQuaternions(quaternion_0, quaternion_1)\n\n    orientations.push(quaternion_0.x, quaternion_0.y, quaternion_0.z, quaternion_0.w)\n\n    //Define variety in height\n    if (i < instances / 3) {\n      stretches.push(Math.random() * 1.8)\n    } else {\n      stretches.push(Math.random())\n    }\n  }\n\n  return {\n    offsets,\n    orientations,\n    stretches,\n    halfRootAngleCos,\n    halfRootAngleSin,\n  }\n}\n\nfunction multiplyQuaternions(q1, q2) {\n  const x = q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x\n  const y = -q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y\n  const z = q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z\n  const w = -q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w\n  return new THREE.Vector4(x, y, z, w)\n}\n\nfunction getYPosition(x, z) {\n  var y = 2 * simplex.noise2D(x / 50, z / 50)\n  y += 4 * simplex.noise2D(x / 100, z / 100)\n  y += 0.2 * simplex.noise2D(x / 10, z / 10)\n  return y\n}\n","import React, { Suspense } from \"react\"\nimport { Canvas } from \"@react-three/fiber\"\nimport { Sky, OrbitControls } from \"@react-three/drei\"\nimport Grass from \"./Grass\"\n\nexport default function App() {\n  return (\n    <Canvas camera={{ position: [15, 15, 30] }}>\n      <Sky azimuth={1} inclination={0.6} distance={1000} />\n      <ambientLight />\n      <pointLight position={[10, 10, 10]} />\n      <Suspense fallback={null}>\n        <Grass />\n      </Suspense>\n      <OrbitControls minPolarAngle={Math.PI / 5} maxPolarAngle={Math.PI / 2.5} />\n    </Canvas>\n  )\n}\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport App from \"./App\"\nimport \"./styles.css\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\"),\n)\n"],"sourceRoot":""}